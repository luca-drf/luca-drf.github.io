[{"categories":null,"contents":"As a Web back-end developer, in general, I\u0026rsquo;ve been quite happy working on an Apple M1 platform. AArch64 is fairly well-supported and Rosetta2 fills most of the gaps left open by the lack of available ARM64 builds.\nAn example of missing support for darwin/arm64 are Oracle Instant Client libs. Luckily there are neat ways around it :)\nProblem Recently I wrote a Python program to extract some data from an \u0026ldquo;old\u0026rdquo; Oracle DB 11.2. Oracle provides a nice Python library to talk with Oracle DB which was recently updated and renamed oracledb. The only problem is that Oracle DB 11.2 is only supported in Thick mode which requires Oracle Instant Client libraries.\nAt the time of writing, Oracle doesn\u0026rsquo;t distribute Oracle Instant Client arm64 builds for macOS and doesn\u0026rsquo;t seem to be planning to. So I wondered how difficult would have been to manage x86 libraries and executables alongside native arm64 ones in order to keep most of my development setup and workflows (i.e. avoiding having to install VMs for developing with x86 libs and x86 Python builds).\nAfter doing some research on the Interwebs, I found two or three solutions that worked, but all of them involved some hackish setup. In the following guide I\u0026rsquo;ll show my approach in which I tried to be as neat and safe as possible.\n(I\u0026rsquo;m assuming XCode and Command Line Tools are already installed on your System)\nHere we go:\nRosetta2 A good way to run darwin/x86_64 software on M1 is using Rosetta2 which is very well integrated in macOS and can be installed by simply:\n/usr/sbin/softwareupdate --install-rosetta --agree-to-license You might get a Package Authoring Error message, but that shouldn\u0026rsquo;t prevent the installation to terminate successfully.\nx86 Terminal The Terminal (in my case iTerm2) is my main entry point in running software when developing, so with Rosetta2 installed I first need an x86 emulated Terminal. That can be achieved by simply \u0026ldquo;right-clicking\u0026rdquo; on iTerm2 app \u0026ldquo;Duplicate\u0026rdquo; it, rename the copied version \u0026ldquo;iTerm-x86\u0026rdquo;, then select it and open the info panel (‚åò-I) and select \u0026ldquo;Open Using Rosetta\u0026rdquo; checkbox. Done. Note that the same can be done with any other macOS app.\nIt\u0026rsquo;s probably a good idea to update your command prompt to display some kind of info about the architecture in order not to get confused when you have two terminals looking exactly the same but running two different environments.\nI\u0026rsquo;ve added the following code to my zsh theme so I can print the arch in my prompt:\narch_prompt() { if [ $(arch) = \u0026#34;i386\u0026#34; ]; then arch_p=\u0026#34;x86\u0026#34; else arch_p=\u0026#34;arm\u0026#34; fi echo $arch_p } Note: you can always launch an x86 shell within your current shell:\narch -x86_64 zsh Also note: env will be inherited in the new zsh session. Personally I find it safer to keep two separated terminals.\nx86 Homebrew Mac Homebrew comes very handy for building and managing OSS on macOS. Since Mac Homebrew on arm64 is rooted at /opt/homebrew instead of /usr/local, it\u0026rsquo;s possible to install x86 software and keep it neatly separated from arm64. You just need to launch an x86 shell and simply install Mac Homebrew.\nThen, in order to make sure your env is properly set, add the following code to your .zprofile (or .profile)\nif [ $(arch) = \u0026#34;i386\u0026#34; ]; then eval \u0026#34;$(/usr/local/bin/brew shellenv)\u0026#34; alias brew=\u0026#34;/usr/local/bin/brew\u0026#34; else eval \u0026#34;$(/opt/homebrew/bin/brew shellenv)\u0026#34; alias brew=\u0026#34;/opt/homebrew/bin/brew\u0026#34; fi x86 Python with Pyenv Now that we have an x86 terminal and a dedicated space for our x86 libraries, we need to build an x86 CPython interpreter. Luckily Pyenv will sort that out for us.\nPyenv In order to build Python, we\u0026rsquo;re going to use Pyenv (which you should be using anyway for managing different Python versions and virtualenvs). Don\u0026rsquo;t worry if you already installed an \u0026ldquo;arm\u0026rdquo; Pyenv and populated Pyenv\u0026rsquo;s root, the two executables won\u0026rsquo;t interfere with each other and can share the same root (e.g. ~/.pyenv).\nSo using our x86 terminal, let\u0026rsquo;s install Pyenv in the x86 space:\nbrew install pyenv pyenv-virtualenv Note: you might need to reload the shell in order for pyenv-virtualenv to work. Also note: brew will take care of openssl and readline dependencies and install their x86 versions in /usr/local/opt.\nLet\u0026rsquo;s also install Pyenv Alias a handy Pyenv plugin for naming Python versions, so we can keep arm and x86 Python builds separated under $(pyenv root)/versions:\ngit clone https://github.com/s1341/pyenv-alias.git $(pyenv root)/plugins/pyenv-alias Python Now we can build an x86 Python interpreter using our x86 terminal and Pyenv. Also let\u0026rsquo;s give it a custom name, so it won\u0026rsquo;t interfere with other arm versions:\nVERSION_ALIAS=\u0026#34;3.10.3_x86\u0026#34; pyenv install 3.10.3 If everything worked fine you should be able to run a Python REPL and check the interpreter platform using the platform module:\n\u0026gt;\u0026gt;\u0026gt; import platform \u0026gt;\u0026gt;\u0026gt; platform.machine() \u0026#39;x86_64\u0026#39; \u0026gt;\u0026gt;\u0026gt; Note that even when using an x86 terminal, an arm built Python interpreter would print 'arm64'.\nOracle Instant Client \u0026amp; Python Finally, we have all we need to install Oracle Instant Client and start using it with Python.\nSo, using our x86 terminal, let\u0026rsquo;s install Oracle Instant Client libraries with brew. We\u0026rsquo;ll need to add a new tap first:\nbrew tap InstantClientTap/instantclient Then we can install the required libs (in my case I only need the basic-lite version).\nbrew install instantclient-basiclite At the time of writing, the above command should install Instant Client Basic Lite version 19.8.0.0.0.\nLet\u0026rsquo;s now create a virtualenv for our project:\npyenv virtualenv 3.10.3_x86 my_project_x86 And activate it:\npyenv activate my_project_x86 Install the new python-oracledb which has replaced the previous cx_Oracle (although the latter would work as well).\npip install oracledb Then let\u0026rsquo;s test that Instant Client is correctly loaded. To do that, run a python REPL and then:\n\u0026gt;\u0026gt;\u0026gt; import oracledb \u0026gt;\u0026gt;\u0026gt; oracledb.init_oracle_client() \u0026gt;\u0026gt;\u0026gt; oracledb.clientversion() (19, 8, 0, 0, 0) \u0026gt;\u0026gt;\u0026gt; Nice, now we can start developing our app!\nDocker As the app I was developing was going to be deployed as a Docker container, I also wondered if there was an easy way to build an x86 Docker image on my M1 Mac and perhaps spin up an x86 container as well, so I could \u0026ldquo;smoke test it\u0026rdquo; locally.\nThe answer is, well, in this case yes!\nPython Toy App For the purpose of this guide the app will simply init Oracle Client and then print its version on stdout.\n# oracle_client_app.py import oracledb oracledb.init_oracle_client() version = oracledb.clientversion() print(f\u0026#34;Oracle Client version: {version[0]}.{version[1]}.{version[2]}\u0026#34;) Dockerfile Now we need a Dockerfile that installs all our dependencies:\nFROM python:3.10.3-slim-buster # Install Oracle Instant Client WORKDIR /opt/oracle RUN apt-get update \\ \u0026amp;\u0026amp; apt-get install -y libaio1 wget unzip \\ \u0026amp;\u0026amp; wget https://download.oracle.com/otn_software/linux/instantclient/1915000/instantclient-basiclite-linux.x64-19.15.0.0.0dbru-2.zip \\ \u0026amp;\u0026amp; unzip instantclient-basiclite-linux.x64-19.15.0.0.0dbru-2.zip \\ \u0026amp;\u0026amp; rm -f instantclient-basiclite-linux.x64-19.15.0.0.0dbru-2.zip \\ \u0026amp;\u0026amp; cd /opt/oracle/instantclient_19_15 \\ \u0026amp;\u0026amp; rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \\ \u0026amp;\u0026amp; echo /opt/oracle/instantclient_19_15 \u0026gt; /etc/ld.so.conf.d/oracle-instantclient.conf \\ \u0026amp;\u0026amp; ldconfig \\ \u0026amp;\u0026amp; apt-get purge -y --auto-remove wget unzip WORKDIR /app COPY oracle_client_app.py /app # Install GCC for compiling python-oracledb and then install it RUN apt-get update \\ \u0026amp;\u0026amp; apt-get install -y gcc \\ \u0026amp;\u0026amp; apt-get clean \\ \u0026amp;\u0026amp; pip install --no-cache-dir oracledb \\ \u0026amp;\u0026amp; apt-get purge -y --auto-remove gcc CMD [\u0026#34;python\u0026#34;, \u0026#34;oracle_client_app.py\u0026#34;] Note: at the time of writing, the latest Oracle Client version for Linux64 is 21.6.0\nBuild and Run We can build our x86 image by using Docker\u0026rsquo;s --platform flag:\ndocker build --platform linux/amd64 -t oracle_client_app And then run it using the same flag:\ndocker run --platform linux/amd64 oracle_client_app:latest Which, if everything went well, should print:\nOracle Client version: 19.15.0 Et voil√†! :)\nConclusion This neat solution wouldn\u0026rsquo;t have been possible without Mac Homebrew maintainers separating x86 installations from arm ones, kudos to them.\nMassive kudos to Apple for Rosetta2 and XCode working seamlessly in emulation mode.\nAnd last but not least, it\u0026rsquo;s really nice to see Docker Desktop for macOS emulating x86 out of the box on arm.\nHappy coding!\n","permalink":"https://lucadrf.dev/blog/oracle-python-m1/","tags":["python","oracle","arm","apple m1","docker"],"title":"Oracle Instant Client and Python on M1"},{"categories":null,"contents":"HUGO is really fast when it comes to building static assets, but its real speed is its linear learning curve.\nBackground I was looking to build a personal website that I could easily update and deploy. I\u0026rsquo;ve used WordPress in the past, but this time I wanted to try something simpler (didn\u0026rsquo;t really need any server-side capabilities). As I\u0026rsquo;m not really a Web front-end developer, and I\u0026rsquo;m not massively interested in diving into UI/UX too deep, my main focus is on content editing and deployment automation.\nBasically I just wanted to be able to write a bunch of Markdown (or similar markup language), compile it into nice HTML (with maybe a little client-side JS code to improve the UX), test it locally (my development platform is an Apple Silicon Mac) then version and deploy it with as little hassle as possible.\nLuckily for me, all the above requirements are covered by a framework called HUGO which is a static website generator written in Go (having basic knowledge of Go helps but isn\u0026rsquo;t really required for effectively use HUGO).\nThe main advantage of maintaining/deploying a static website is that it only requires a CDN to be served (with obvious advantages also in terms of security/privacy and testing), so in this case I\u0026rsquo;m hosting this site using GitHub Pages which provides the CDN and all the CI/CD tools I need in one place.\nDevelopment First I\u0026rsquo;ve installed HUGO I\u0026rsquo;m developing on an Apple Silicon Mac, and HUGO can be easily installed via Mac Homebrew with:\nbrew install hugo Then I created a new site:\nhugo new site lucadrf.dev At this point I needed a base theme, as I didn\u0026rsquo;t want to build the whole site from scratch (and had zero experience with HUGO). There are hundreds of themes to chose from that span several use cases. In my case I wanted mainly a \u0026ldquo;resume style\u0026rdquo; home page with maybe a blog space. I\u0026rsquo;ve found just what I was looking for with this theme which code was conveniently hosted on GitHub as well (thank you eddiewebb).\nAs I wanted to add several changes to the theme I figured it would have been cleaner to fork it and maintain my own (simplified) version. So I did it and added my own fork to the project as a submodule:\ncd lucadrf.dev git init git submodule add https://github.com/luca-drf/hugo-resume.git themes/hugo-resume Using exampleSite as reference I\u0026rsquo;ve added my:\ndata/skills.json data/experience.json data/education.json Then updated config.toml and finally built the site with:\nhugo The entire website will be compiled and stored in ./public (default) as static assets.\nA really nice feature is the development web server which serves the site locally and can be configured to rebuild/reload upon changes. To run the server I\u0026rsquo;ve simply:\nhugo server More info about setting up HUGO and the theme at:\nHUGO Quickstart Hugo Resume Deployment After several iterations of coding and local testing, and having obtained a decent site, I\u0026rsquo;ve set up automated deploy on GitHub Pages, taking advantage of GitHub Actions and its community. In fact there are already two repositories with a comprehensive set of Actions for HUGO in order to build and deploy on GitHub Pages.\nThe workflow consists in having a GitHub Pages repository for the project with a dedicated branch (gh-pages) working as a \u0026ldquo;deployment\u0026rdquo; space for the built assets (i.e. the content of ./public), then configure GitHub Pages to serve the assets on gh-pages rather than main.\nHere\u0026rsquo;s the complete workflow:\nname: GitHub Pages on: push: branches: - main # Set a branch name to trigger deployment pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.97.2\u0026#39; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public So every push onto main will trigger an Action that will build the site and then push the resulting assets onto gh-pages.\nI\u0026rsquo;m keeping main as a \u0026ldquo;release\u0026rdquo; branch and have dev as the main development branch.\nIn order to create a new blog post then I\u0026rsquo;ll simply\u0026hellip;\nhugo new blog/new-blog-title.md \u0026hellip;and start adding content. Once the post is done, I can quickly check it locally, then merge/push onto main and voil√† üíÅüèª‚Äç‚ôÇÔ∏è üòÉ\nMore info on building and hosting on GitHub:\nHosting HUGO on GitHub Tips And Tricks When building/serving locally, HUGO uses a cache directory ($TMP_DIR/hugo_cache by default). In some cases you might want to ignore the cache and rebuild everything (e.g. changing certain file names might break the build if the cache is not invalidated) so you can pass --ignoreCache to hugo or hugo server commands. Conclusion I think the main strengths of HUGO are its modularity (both in terms of project layout and functionalities) and its community. I also appreciated its good balance between conventions and configurations make it overall extremely flexible yet easy to pick up while using it or, in other terms, very Agile. Also, the complexity doesn\u0026rsquo;t seem to grow dramatically when adding new features and/or diverging from what the theme was initially designed to do.\nSo, I\u0026rsquo;ve had good fun in building this site so far, and I\u0026rsquo;ll definitely keep diving into HUGO.\n","permalink":"https://lucadrf.dev/blog/building-this-site-with-hugo/","tags":["web development","hugo","github"],"title":"Building this site with HUGO"}]