[{"categories":null,"contents":"TL;DR See this gist\nProblem Most of Microsoft Azure\u0026rsquo;s Python packages have uAMQP (azure-uamqp-python) as a dependency, hence if you\u0026rsquo;re developing any automation involving Azure with Python, you\u0026rsquo;d almost certainly need to install it in your pipeline. Under the hood, Python uAMQP uses its C counterpart azure-uamqp-c as an extension, therefore that\u0026rsquo;s required as an appropriate byte-compiled library for the target architecture, system and Python version the pipeline is running on.\nIn most cases, third-party Python packages that requires C extensions are shipped in archives where the Python code is packaged alongside the compiled extensions. Such archives are called wheels and can be installed as any other third-party package, using Pip, given that pre-built wheels targeting architecture, system and Python version Pip is installing on, are provided and available on the PyPI repository for the package.\nMicrosoft is publishing uAMQP Python wheels targeting Windows, Linux and MacOS, and for all live major Python 3 versions (3.7+). The only problem is that the only targeted architecture is x86_64 (see last uAMQP release on PyPI).\nTo be fair the source code is well engineered and can be fairly easily compiled for Linux on Arm architectures, in fact uAMQP GitHub repo, features build scripts for Python 3.5 on armV7 (which could probably work on a Raspberry PI 2 see here) but the Manylinux one is strictly targeting x86_64.\nSo as arm64v8 based servers are becoming widely adopted by public Cloud providers, I find quite peculiar the lack of arm64 pre-built wheels on PyPI. It\u0026rsquo;s definitely not a technical challenge/burden for uAMQP maintainers (I think), and I hope they\u0026rsquo;ll start providing them, and so are other devs on azure-uamqp-python\u0026rsquo;s Issues on GitHub.\nDon\u0026rsquo;t get me wrong, I\u0026rsquo;m really glad the direction Microsoft took in the last decade, heavily investing on Open Source and Python. Kudos to them!\nA solution So in the meantime, if you need to build uAMQP for your Linux system running on Arm, below is a build script that should do the trick. It requires docker and an image provided by the amazing Manylinux project.\nCross compile aarch64 on x86_64 Note that you can use the same script to cross compile for aarch64 on a Linux x86_64 machine, thanks to the very clever qemu-user-static docker image by simply running the following container before the above script:\ndocker run --rm --privileged multiarch/qemu-user-static --reset -p yes I\u0026rsquo;m not going to go into details on how the above works as it\u0026rsquo;s a bit out of the scope of this post, but I strongly recommend to everyone reading about it as what they did is a beautiful hack and, in my opinion, shows why running containers in privileged mode can be both powerful and extremely dangerous at the same time.\n","permalink":"https://lucadrf.dev/blog/uamqp-manylinux-arm64/","tags":["python","arm","manylinux","microsoft","azure"],"title":"Build uAMQP Python wheel for arm64v8"},{"categories":null,"contents":"TL;DR Here\u0026rsquo;s how to read and print a subprocess stdout in \u0026ldquo;real-time\u0026rdquo;, or in other words, capture the subprocess\u0026rsquo; stdout as soon as bytes are written to it.\n# parent_process.py from subprocess import Popen, PIPE with Popen([\u0026#34;python\u0026#34;, \u0026#34;child_process.py\u0026#34;], stdout=PIPE) as p: while True: # Use read1() instead of read() or Popen.communicate() as both blocks until EOF # https://docs.python.org/3/library/io.html#io.BufferedIOBase.read1 text = p.stdout.read1().decode(\u0026#34;utf-8\u0026#34;) print(text, end=\u0026#39;\u0026#39;, flush=True) # child_process.py from time import sleep while True: # Make sure stdout writes are flushed to the stream print(\u0026#34;Spam!\u0026#34;, end=\u0026#39; \u0026#39;, flush=True) # Sleep to simulate some other work sleep(1) If you\u0026rsquo;d like to learn more about Python\u0026rsquo;s I/O, buffers configuration, and a real life problem that inspired this blog post, keep reading :)\nProblem On a Python group chat I\u0026rsquo;ve read an interesting question, I\u0026rsquo;m reporting an edited version below:\nI have a script that opens a program with Popen. stdout is redirected to a PIPE. The script reads few lines on stdout to discover how to connect to the program using a socket. Unfortunately, at some point later the stdout pipe gets full as it isn\u0026rsquo;t read, and it blocks the subprocess.\nThat behaviour is expected, in fact, it\u0026rsquo;s mentioned in Python\u0026rsquo;s subprocess docs for Popen.wait()\nThis will deadlock when using stdout=PIPE or stderr=PIPE and the child process generates enough output to a pipe such that it blocks waiting for the OS pipe buffer to accept more data.\n(Note: I have omitted the last sentence about Popen.communicate() as it\u0026rsquo;s not relevant for our case, I\u0026rsquo;ll go back to it in more detail later.)\nSo, how can we read the first few lines written by a subprocess on its stdout, save them and throw away the rest while the subprocess is running and writing without stopping it?\nTL;DR (part 2), take me to the solution\nA solution Using a text file instead of a pipe We could redirect our subprocess stdout to a file instead of a pipe, read the first few lines and forget about the rest until the subprocess terminate and then delete the file.\nThat would possibly look something like this:\nfrom subprocess import Popen from time import sleep max_lines_to_read = 10 lines_read = 0 with open(\u0026#34;my_command.out\u0026#34;, \u0026#34;w\u0026#34;) as subprocess_out: with Popen([\u0026#34;my_command\u0026#34;], stdout=subprocess_out) as process: with open(\u0026#34;my_command.out\u0026#34;, \u0026#34;r\u0026#34;) as subprocess_in: while True: text = subprocess_in.read() if not text: sleep(1) continue if lines_read \u0026lt; max_lines_to_read: if text.endswith(\u0026#34;\\n\u0026#34;): # TODO: Store or use the whole line lines_read += 1 else: break # TODO: Write the rest of the logic here and terminate `process` if needed Note: I didn\u0026rsquo;t use readline() or readlines() because they would behave just like read() if our subprocess doesn\u0026rsquo;t terminate each write with a new line (i.e. use one write per line) so it\u0026rsquo;s less confusing to simply use read() and look for \\n ourselves.\nThis solution works, but if we\u0026rsquo;re only interested in few lines there\u0026rsquo;s really no point in having that file on disk, what if it ends up being several gigabytes and the subprocess having to run for days? You don\u0026rsquo;t want to be that person who forced IT to impose stricter quotas on your VMs mounts, do you? üòâ\nNo, we\u0026rsquo;re dealing with a stream of data, and we should be coding accordingly.\nSo, how can we stream the output of a subprocess as it gets generated, rather than waiting for it to terminate and print it all?\nWhat does the official Python documentation suggest? If we read Python\u0026rsquo;s official documentation (as all good Pythonistas always do) for subprocess module, we\u0026rsquo;re strongly encouraged to use Popen.communicate() for writing/reading piped subprocesses STDIN/STDOUT. That doesn\u0026rsquo;t quite work the way we expect though, in fact communicate() seems to be blocking and even calling it with a timeout communicate(timeout=2) doesn\u0026rsquo;t seem to work as bytes aren\u0026rsquo;t returned while the pipe is open and being written. Bummer.\nUnfortunately Python\u0026rsquo;s official documentation doesn\u0026rsquo;t offer any alternative solution, \u0026ldquo;There should be one \u0026ndash; and preferably only one \u0026ndash; obvious way to do it.\u0026rdquo; the Zen of Python says, although using Popen.communicate() to read the stdout of a piped subprocess is all but obvious. Sorry Zen of Python and official docs, but we have to find another way.\nPython buffers and I/O While trying to figure out why Popen.communicate() didn\u0026rsquo;t work as expected I\u0026rsquo;ve refreshed my knowledge on POSIX pipes and buffering strategies in libc. There are essentially three kinds of streams:\nUnbuffered (characters are transmitted individually, as soon as possible) Line buffered (characters are transmitted in blocks, when new line is encountered) Fully buffered (characters are transmitted in blocks of arbitrary size) See GNU Buffering Concepts.\nTypically, POSIX pipes are fully buffered streams, while streams attached to a TTY are usually line buffered. It\u0026rsquo;s important to remember that, especially when redirecting stdout to a pipe or a file (instead of a terminal).\nPython follows the same strategies when implementing its buffers, and it\u0026rsquo;s also worth remembering that an extra layer of internal buffering might occur on both reads and writes.\nLastly, it\u0026rsquo;s important to remember that stdout streams in Python can be handled by different io classes, depending on the type of stream/buffering strategy.\nLine buffered streams (TTY) Consider the following program, I\u0026rsquo;ve called it spam_one_line.py:\n# spam_one_line.py import sys from time import sleep for _ in range(8): print(\u0026#34;Spam!\u0026#34;, end=\u0026#39; \u0026#39;) # Printed string ends with a space instead of the default sleep(1) print(\u0026#34;Lovely Spam! Wonderful Spam!\u0026#34;) print(\u0026#34;Line written\u0026#34;, file=sys.stderr) What do you think the output of this program will be on your terminal? Or more importantly, when do you think those characters will appear?\nSpoiler alert: two lines will appear at the same time:\nSpam! Spam! Spam! Spam! Spam! Spam! Spam! Spam! Lovely Spam! Wonderful Spam! Line written That\u0026rsquo;s because stdout and stderr are both attached to a TTY and that by default means sys.stdout and sys.stderr are instances of io.TextIOWrapper (which is the same type of instance that is returned by open() when opening a text file) but with line_buffering=True. Hence, characters are flushed onto the underlying binary buffer when new line is encountered.\nIt\u0026rsquo;s easy to check whether a stream is attached to a TTY as io.IOBase class implements isatty() method that can be invoked on all its subclasses; in this case sys.stdout.isatty() == True.\nSo what if we want to \u0026ldquo;print immediately\u0026rdquo; on stdout? Well, one way to do it is to call print() with flush=True:\nprint(\u0026#34;Spam!\u0026#34;, end=\u0026#39; \u0026#39;, flush=True) From Python 3.7 onwards, another way is to reconfigure sys.stdout to disable the interpreter\u0026rsquo;s buffer and transmit all the subsequent writes to the system buffer:\nsys.stdout.reconfigure(write_through=True) Fully buffered streams (pipe) What buffering strategy and what type of stream is Python implementing when a Python process is invoked using subprocess.Popen and its stdout is redirected to a pipe instead of being attached to a TTY?\nLet\u0026rsquo;s first refresh what a pipe is and how it works:\nIn very simple terms, a pipe is a mechanism for multiprocess communication provided by the OS. It has two separate ends, a writing and a reading one. The data is handled in a first-in, first-out (FIFO) order.\nSo when we call subprocess.Popen and redirect the subprocess\u0026rsquo; stdout to a pipe, Popen first creates the pipe, which means creating the two ends as two separate binary file descriptors pointing to the same file (one in reading mode and one in writing mode); then forks the calling process (creating a child process which will share both file descriptors), redirect the child process stdout to the file descriptor pointing at the writing end of the pipe, and finally exec the program that should run as the child process.\nFor more info see libc\u0026rsquo;s Pipes and FIFOs, Creating a pipe and Pipe atomicity documentation.\nSo for example if we instantiate a process object as:\nwith subprocess.Popen([\u0026#34;my_command\u0026#34;], stdout=subprocess.PIPE) as process: ... Then process.stdout will hold the reading end of the pipe while (assuming \u0026ldquo;my_command\u0026rdquo; is another Python program) the child process\u0026rsquo; sys.stdout will hold the writing end.\nIt\u0026rsquo;s important to notice that the reading end is handled by an instance of io.BufferedReader as it\u0026rsquo;s open in binary reading mode while the writing end will still be handled by an instance of io.TextIOWrapper (again, assuming the child process runs a Python program) but in this case both sys.stdout.isatty() and sys.stdout.line_buffering will evaluate to False.\nConfiguring a subprocess piped STDOUT Okay, so, using a io.BufferedReader instance in our use case isn\u0026rsquo;t great, because we basically want to read lines from stdout as if it was attached to a TTY. So, is there a way to reconfigure our piped subprocess stdout buffering strategy? Luckily, this time, the answer can be found by reading Popen docs and its many, many options; in fact, setting bufsize=1 and universal_newlines=True when invoking Popen, will change the reading end of our pipe\u0026rsquo;s type to io.TextIOWrapper and the underlying buffer will be line buffered. Note that the wrapper\u0026rsquo;s buffer on top of the binary one, instead, will have line_buffering=False (which is a bit confusing but coherent).\nSo, having io.TextIOWrapper instead of io.BufferedReader as our reading end, make Popen.communicate() non-blocking and behave as we expect? Sadly, no. But, we can read directly from the stdout stream of our subprocess, remember? And since our reading end (process.stdout) is an instance of io.TextIOWrapper and the buffering strategy is line buffered we can call readline() on it and expect it to block until a full line is available on the buffer and return it.\nSo now we should have all what we need to solve our initial problem in a better way.\nAnother (but better) solution Instead of dumping our subprocess output to a file, reading the first few lines and forgetting about the following ones; we could consume the subprocess\u0026rsquo; output in a separate thread, send the first few lines to the parent process using a queue and then continue to consume the rest of the output in the thread (and discarding it). This way we\u0026rsquo;d use only the memory we need.\nfrom subprocess import Popen, PIPE from threading import Thread from queue import SimpleQueue def consume_output(p, q, max_lines): line_count = 0 while p.poll() is None: line = p.stdout.readline() if line_count \u0026lt; max_lines: q.put(line) line_count += 1 def main(max_lines): program_output = [] line_count = 0 with Popen([\u0026#34;my_command\u0026#34;], stdout=PIPE, bufsize=1, universal_newlines=True) as p: q = SimpleQueue() t = Thread(target=consume_output, args=(p, q, max_lines)) t.start() while True: line = q.get() program_output.append(line) line_count += 1 if line_count == max_lines: break # TODO: Write the rest of the logic here and do what you need with `program_output` p.terminate() t.join() # Blocks until t terminates if __name__ == \u0026#34;__main__\u0026#34;: main(max_lines=2) Note: we\u0026rsquo;re using Popen.poll() to check whether the child process is running or has terminated, in case it has been terminated, the thread shall also terminate.\nAlso note that if \u0026ldquo;my_command\u0026rdquo; is a Python program as well, you\u0026rsquo;ll have to remember to flush prints that you want to transmit immediately, because since sys.stdout has been redirected to a pipe then sys.stdout.line_buffering == False and the buffer will be flushed only when the underlying binary buffer is full.\n# spam_many_lines.py import sys from time import sleep while True: for _ in range(8): print(\u0026#34;Spam!\u0026#34;, end=\u0026#39; \u0026#39;, flush=True) sleep(1) print(\u0026#34;Lovely Spam! Wonderful Spam!\u0026#34;, flush=True) print(\u0026#34;Line written\u0026#34;, file=sys.stderr) Problem solved.\nThat\u0026rsquo;s great, but the title of this blog post mentions capturing output in \u0026ldquo;real time\u0026rdquo;; so what if the child process doesn\u0026rsquo;t atomically writes full lines? For example, what if we want to capture the output of one of those command line programs that print their progress on one line (e.g. with a progress-bar)? In that case reading line-by-line wouldn\u0026rsquo;t be of much use.\nReal-Time output In an earlier section, we talked about our subprocess piped stdout being handled by a io.BufferedReader instance; that is the default mode subprocess.Popen instantiates our process.stdout.\nBy default, io.BufferedReader, handles a fully buffered, binary stream, and implements a read() method, although that blocks until EOF if called with a negative o no parameter, otherwise if called with a positive integer n will block until n bytes are read.\nI must say, io.BufferedReader.read() behaviour is not very clear from the official Python documentation in my opinion especially because other read methods like io.TextIOWrapper.read() or os.read() return \u0026ldquo;up to\u0026rdquo; n bytes when called with a positive integer, which means they won\u0026rsquo;t block.\nSo, is there a way to read bytes from a binary buffer as soon as they\u0026rsquo;re written, without having to wait for EOF (hence before the writing process closes the pipe), and without having to read byte by byte with read(1) (which is not very efficient)?\nLuckily, that can be achieved by using a different read method: io.BufferedReader.read1() (even though, again, the official Python documentation is not super clear).\nAnother option would be calling os.read() passing the subprocess\u0026rsquo; stdout file descriptor and a positive n in order to read at most n bytes per call.\nLet\u0026rsquo;s write a simple program that just reads the subprocess stdout and prints it in real-time:\nimport sys from subprocess import Popen, PIPE with Popen([\u0026#34;my_command\u0026#34;], stdout=PIPE) as p: while True: text = p.stdout.read1().decode(\u0026#34;utf-8\u0026#34;) print(text, end=\u0026#39;\u0026#39;, flush=True) # TODO: Write the rest of the logic here and terminate `process` if needed That\u0026rsquo;s it!\nNote that, alternatively, you could have also used os.read() in case you wanted to read up to a fixed number of bytes, so you could have rewritten the read line as:\ntext = os.read(p.stdout.fileno(), 1024).decode(\u0026#34;utf-8\u0026#34;) (Obviously you\u0026rsquo;d have to import os for that)\nMore on Python buffers The default buffer size of all concrete io.Buffered* classes is io.DEFAULT_BUFFER_SIZE which is platform dependant.\nIn case you wanted to change buffer strategy for stdout stream, you can re-initialise it. For example, in the above spam_many_lines.py you might want to set custom buffer settings in case stdout is not attached to a TTY, but keep default settings otherwise (and/or not want to pass flush=True to all print() functions).\nSo you could first check if sys.stdout is attached to a TTY, then disable io.TextIOWrapper buffer and instead set a custom buffer size for the underlying binary buffer.\nif not sys.stdout.isatty(): buff_size = 8 sys.stdout = io.TextIOWrapper( open(sys.stdout.fileno(), \u0026#39;wb\u0026#39;, buff_size), write_through=True, encoding=\u0026#34;utf-8\u0026#34; ) Note, stdout buffer will be automatically flushed after 8 bytes have been written.\nAnd that\u0026rsquo;s all I\u0026rsquo;ve got on Python buffers for now.\nIf you made it here, give yourself a pat on the back and see you soon!\n","permalink":"https://lucadrf.dev/blog/python-subprocess-buffers/","tags":["python","subprocess","unix"],"title":"Capture Python subprocess output in real-time"},{"categories":null,"contents":"As a Web back-end developer, in general, I\u0026rsquo;ve been quite happy working on an Apple M1 platform. AArch64 is fairly well-supported and Rosetta2 fills most of the gaps left open by the lack of available ARM64 builds.\nAn example of missing support for darwin/arm64 are Oracle Instant Client libs. Luckily there are neat ways around it üôÇ\nProblem Recently I wrote a Python program to extract some data from an \u0026ldquo;old\u0026rdquo; Oracle DB 11.2. Oracle provides a nice Python library to talk with Oracle DB which was recently updated and renamed oracledb. The only problem is that Oracle DB 11.2 is only supported in Thick mode which requires Oracle Instant Client libraries.\nAt the time of writing, Oracle doesn\u0026rsquo;t distribute Oracle Instant Client arm64 builds for macOS and doesn\u0026rsquo;t seem to be planning to. So I wondered how difficult would have been to manage x86 libraries and executables alongside native arm64 ones in order to keep most of my development setup and workflows (i.e. avoiding having to install VMs for developing with x86 libs and x86 Python builds).\nAfter doing some research on the Interwebs, I found two or three solutions that worked, but all of them involved some hackish setup. In the following guide I\u0026rsquo;ll show my approach in which I tried to be as neat and safe as possible.\n(I\u0026rsquo;m assuming XCode and Command Line Tools are already installed on your System)\nHere we go:\nRosetta2 A good way to run darwin/x86_64 software on Apple Silicon is using Rosetta2 which is very well integrated in macOS and can be installed by simply:\n/usr/sbin/softwareupdate --install-rosetta --agree-to-license You might get a Package Authoring Error message, but that shouldn\u0026rsquo;t prevent the installation to terminate successfully.\nx86 Terminal The Terminal (in my case iTerm2) is my main entry point for running software when developing, so with Rosetta2 installed I first need an x86 emulated Terminal. That can be achieved by simply \u0026ldquo;right-clicking\u0026rdquo; on iTerm2 app, \u0026ldquo;Duplicate\u0026rdquo; it, rename the copied version \u0026ldquo;iTerm-x86\u0026rdquo;, then select it and open the info panel (‚åò-I), and finally select \u0026ldquo;Open Using Rosetta\u0026rdquo; checkbox. Done. Note that the same can be done with any other macOS app.\nIt\u0026rsquo;s probably a good idea to update your command prompt to display some kind of info about the architecture in order not to get confused when you have two terminals looking exactly the same but running two different environments.\nI\u0026rsquo;ve added the following code to my zsh theme and included the variable in my prompt.\nif [ $(arch) = \u0026#34;i386\u0026#34; ]; then ARCH_PROMPT=\u0026#34;x86\u0026#34; else ARCH_PROMPT=\u0026#34;arm\u0026#34; fi Note: you can always launch an x86 shell within your current shell:\narch -x86_64 zsh Also note: the environment will be inherited in the new shell session. Personally I find it safer to keep two separated terminals.\nx86 Homebrew Mac Homebrew comes very handy for building and managing OSS on macOS. Since Mac Homebrew on arm64 is rooted at /opt/homebrew instead of /usr/local, it\u0026rsquo;s possible to install x86 software and keep it neatly separated from arm64. You just need to launch an x86 shell and simply install Mac Homebrew. It will automatically choose its root based on the detected architecture (in our case i386).\nThen, in order to make sure your environment is properly set, add the following code to your .zprofile (or .profile):\nif [ $(arch) = \u0026#34;i386\u0026#34; ]; then eval \u0026#34;$(/usr/local/bin/brew shellenv)\u0026#34; else eval \u0026#34;$(/opt/homebrew/bin/brew shellenv)\u0026#34; fi x86 Python with Pyenv Now that we have an x86 terminal and a dedicated space for our x86 libraries, we need to build an x86 CPython interpreter. Luckily Pyenv will sort that out for us.\nPyenv In order to build Python, we\u0026rsquo;re going to use Pyenv (which you should be using already for managing different Python versions and virtualenvs anyway). Don\u0026rsquo;t worry if you already installed an \u0026ldquo;arm\u0026rdquo; Pyenv, and have already populated Pyenv\u0026rsquo;s root; the two executables won\u0026rsquo;t interfere with each other as they can share the same root (e.g. ~/.pyenv).\nSo using our x86 terminal, let\u0026rsquo;s install Pyenv in the x86 space:\nbrew install pyenv pyenv-virtualenv Note: you might need to reload the shell in order for pyenv-virtualenv to work. Also note: brew will take care of openssl and readline dependencies installing their x86 versions in /usr/local/opt.\nLet\u0026rsquo;s also install Pyenv Alias a handy Pyenv plugin for labelling Python versions, so we can keep arm and x86 Python builds separated under $(pyenv root)/versions:\ngit clone https://github.com/s1341/pyenv-alias.git $(pyenv root)/plugins/pyenv-alias Python Now we can build an x86 Python interpreter using our x86 terminal and Pyenv. Also, let\u0026rsquo;s give it a custom name, so it won\u0026rsquo;t interfere with other arm versions:\nVERSION_ALIAS=\u0026#34;3.10.3_x86\u0026#34; pyenv install 3.10.3 If everything worked fine, you should be able to run a Python REPL and check the interpreter platform using the platform module:\n\u0026gt;\u0026gt;\u0026gt; import platform \u0026gt;\u0026gt;\u0026gt; platform.machine() \u0026#39;x86_64\u0026#39; \u0026gt;\u0026gt;\u0026gt; Note that even when using an x86 terminal, an arm built Python interpreter would print 'arm64'.\nOracle Instant Client \u0026amp; Python Finally, we have all that we need to install Oracle Instant Client, and calling it from Python.\nSo, using our x86 terminal, let\u0026rsquo;s install Oracle Instant Client libraries with brew. We\u0026rsquo;ll need to add a new tap first:\nbrew tap InstantClientTap/instantclient Then we can install the required libs (in my case, I only needed the basic-lite version):\nbrew install instantclient-basiclite At the time of writing, the above command should install Instant Client Basic Lite version 19.8.0.0.0.\nLet\u0026rsquo;s now create a virtualenv for our project:\npyenv virtualenv 3.10.3_x86 oracle_client_app And activate it:\npyenv activate oracle_client_app Let\u0026rsquo;s install the new python-oracledb which has replaced cx_Oracle (although the latter would work as well):\npip install oracledb Then test that Instant Client is correctly loaded. To do that, open a python REPL and then:\n\u0026gt;\u0026gt;\u0026gt; import oracledb \u0026gt;\u0026gt;\u0026gt; oracledb.init_oracle_client() \u0026gt;\u0026gt;\u0026gt; oracledb.clientversion() (19, 8, 0, 0, 0) \u0026gt;\u0026gt;\u0026gt; Nice, now we can start developing our app!\nDocker As the app I was developing was going to be deployed as a Docker container, I also wondered if there was an easy way to build an x86 Docker image on my M1 Mac; and perhaps, spin up an x86 container as well, so I could \u0026ldquo;smoke test it\u0026rdquo; locally.\nThe answer is, well, in this case yes!\nPython Toy App For the purpose of this guide the app will simply init Oracle Client and then print its version on stdout.\n# oracle_client_app.py import oracledb oracledb.init_oracle_client() version = oracledb.clientversion() print(f\u0026#34;Oracle Client version: {version[0]}.{version[1]}.{version[2]}\u0026#34;) Dockerfile Now we need a Dockerfile that installs all our dependencies:\nFROM python:3.10.3-slim-buster # Install Oracle Instant Client WORKDIR /opt/oracle RUN apt-get update \\ \u0026amp;\u0026amp; apt-get install -y libaio1 wget unzip \\ \u0026amp;\u0026amp; wget https://download.oracle.com/otn_software/linux/instantclient/1915000/instantclient-basiclite-linux.x64-19.15.0.0.0dbru-2.zip \\ \u0026amp;\u0026amp; unzip instantclient-basiclite-linux.x64-19.15.0.0.0dbru-2.zip \\ \u0026amp;\u0026amp; rm -f instantclient-basiclite-linux.x64-19.15.0.0.0dbru-2.zip \\ \u0026amp;\u0026amp; cd /opt/oracle/instantclient_19_15 \\ \u0026amp;\u0026amp; rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \\ \u0026amp;\u0026amp; echo /opt/oracle/instantclient_19_15 \u0026gt; /etc/ld.so.conf.d/oracle-instantclient.conf \\ \u0026amp;\u0026amp; ldconfig \\ \u0026amp;\u0026amp; apt-get purge -y --auto-remove wget unzip WORKDIR /app COPY oracle_client_app.py /app # Install GCC for compiling python-oracledb and then install it RUN apt-get update \\ \u0026amp;\u0026amp; apt-get install -y gcc \\ \u0026amp;\u0026amp; apt-get clean \\ \u0026amp;\u0026amp; pip install --no-cache-dir oracledb \\ \u0026amp;\u0026amp; apt-get purge -y --auto-remove gcc CMD [\u0026#34;python\u0026#34;, \u0026#34;oracle_client_app.py\u0026#34;] Note: at the time of writing, the latest Oracle Client version for Linux64 is 21.6.0\nBuild and Run We can build our x86 image by using Docker\u0026rsquo;s --platform parameter:\ndocker build --platform linux/amd64 -t oracle_client_app And then run it using the same parameter:\ndocker run --platform linux/amd64 oracle_client_app:latest Which, if everything went well, should print:\nOracle Client version: 19.15.0 Et voil√†! üíÅüèª‚Äç‚ôÇÔ∏è\nConclusion This neat solution wouldn\u0026rsquo;t have been possible without Mac Homebrew maintainers separating x86 installations from arm ones, kudos to them.\nMassive kudos to Apple for Rosetta2 and XCode working seamlessly in emulation mode.\nAnd last but not least, it\u0026rsquo;s really nice to see Docker Desktop for macOS emulating x86 out of the box on Apple Silicon.\nHappy coding!\n","permalink":"https://lucadrf.dev/blog/oracle-python-m1/","tags":["python","oracle","arm","apple m1","docker"],"title":"Oracle Client and Python on Apple Silicon"},{"categories":null,"contents":"HUGO is really fast when it comes to building static assets, but its real speed is its linear learning curve.\nBackground I was looking to build a personal website that I could easily update and deploy. I\u0026rsquo;ve used WordPress in the past, but this time I wanted to try something simpler (didn\u0026rsquo;t really need any server-side capabilities). As I\u0026rsquo;m not really a Web front-end developer, and I\u0026rsquo;m not massively interested in diving into UI/UX too deep, my main focus is on content editing and deployment automation.\nBasically I just wanted to be able to write a bunch of Markdown (or similar markup language), compile it into nice HTML (with maybe a little client-side JS code to improve the UX), test it locally (my development platform is an Apple Silicon Mac) then version and deploy it with as little hassle as possible.\nLuckily for me, all the above requirements are covered by a framework called HUGO which is a static website generator written in Go (having basic knowledge of Go helps but isn\u0026rsquo;t really required for effectively use HUGO).\nThe main advantage of maintaining/deploying a static website is that it only requires a CDN to be served (with obvious advantages also in terms of security/privacy and testing), so in this case I\u0026rsquo;m hosting this site using GitHub Pages which provides the CDN and all the CI/CD tools I need in one place.\nDevelopment First I\u0026rsquo;ve installed HUGO I\u0026rsquo;m developing on an Apple Silicon Mac, and HUGO can be easily installed via Mac Homebrew with:\nbrew install hugo Then I created a new site:\nhugo new site lucadrf.dev At this point I needed a base theme, as I didn\u0026rsquo;t want to build the whole site from scratch (and had zero experience with HUGO). There are hundreds of themes to chose from that span several use cases. In my case I wanted mainly a \u0026ldquo;resume style\u0026rdquo; home page with maybe a blog space. I\u0026rsquo;ve found just what I was looking for with this theme which code was conveniently hosted on GitHub as well (thank you eddiewebb).\nAs I wanted to add several changes to the theme I figured it would have been cleaner to fork it and maintain my own (simplified) version. So I did it and added my own fork to the project as a submodule:\ncd lucadrf.dev git init git submodule add https://github.com/luca-drf/hugo-resume.git themes/hugo-resume Using exampleSite as reference I\u0026rsquo;ve added my:\ndata/skills.json data/experience.json data/education.json Then updated config.toml and finally built the site with:\nhugo The entire website will be compiled and stored in ./public (default) as static assets.\nA really nice feature is the development web server which serves the site locally and can be configured to rebuild/reload upon changes. To run the server I\u0026rsquo;ve simply:\nhugo server More info about setting up HUGO and the theme at:\nHUGO Quickstart Hugo Resume Deployment After several iterations of coding and local testing, and having obtained a decent site, I\u0026rsquo;ve set up automated deploy on GitHub Pages, taking advantage of GitHub Actions and its community. In fact there are already two repositories with a comprehensive set of Actions for HUGO in order to build and deploy on GitHub Pages.\nThe workflow consists in having a GitHub Pages repository for the project with a dedicated branch (gh-pages) working as a \u0026ldquo;deployment\u0026rdquo; space for the built assets (i.e. the content of ./public), then configure GitHub Pages to serve the assets on gh-pages rather than main.\nHere\u0026rsquo;s the complete workflow:\nname: GitHub Pages on: push: branches: - main # Set a branch name to trigger deployment pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.97.2\u0026#39; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public So every push onto main will trigger an Action that will build the site and then push the resulting assets onto gh-pages.\nI\u0026rsquo;m keeping main as a \u0026ldquo;release\u0026rdquo; branch and have dev as the main development branch.\nIn order to create a new blog post then I\u0026rsquo;ll simply\u0026hellip;\nhugo new blog/new-blog-title.md \u0026hellip;and start adding content. Once the post is done, I can quickly check it locally, then merge/push onto main and voil√† üíÅüèª‚Äç‚ôÇÔ∏è üòÉ\nMore info on building and hosting on GitHub:\nHosting HUGO on GitHub Tips And Tricks When building/serving locally, HUGO uses a cache directory ($TMP_DIR/hugo_cache by default). In some cases you might want to ignore the cache and rebuild everything (e.g. changing certain file names might break the build if the cache is not invalidated) so you can pass --ignoreCache to hugo or hugo server commands. Conclusion I think the main strengths of HUGO are its modularity (both in terms of project layout and functionalities) and its community. I also appreciated its good balance between conventions and configurations make it overall extremely flexible yet easy to pick up while using it or, in other terms, very Agile. Also, the complexity doesn\u0026rsquo;t seem to grow dramatically when adding new features and/or diverging from what the theme was initially designed to do.\nSo, I\u0026rsquo;ve had good fun in building this site so far, and I\u0026rsquo;ll definitely keep diving into HUGO.\n","permalink":"https://lucadrf.dev/blog/building-this-site-with-hugo/","tags":["web development","hugo","github"],"title":"Building this site with HUGO"}]