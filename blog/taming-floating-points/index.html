<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Luca Da Rin Fioretto | Taming Floating-Point Arithmetic in Python (Part 1)</title><meta property="og:title" content="Luca Da Rin Fioretto | Taming Floating-Point Arithmetic in Python (Part 1)"><meta property="og:image" content="https://i.ibb.co/SndJ6g0/rob-thompson-om-Uf5-OUJx-Xc-unsplash.jpg"><meta property="og:description" content="Blog post on common gotchas in IEEE-754 floating-point arithmetic, with practical and realistic examples using Python's built-in float (double-precision)."><meta name=description content="Blog post on common gotchas in IEEE-754 floating-point arithmetic, with practical and realistic examples using Python's built-in float (double-precision)."><meta name=author content="Luca Da Rin Fioretto"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#176d86><meta name=msapplication-TileColor content="#2b5797"><meta name=theme-color content="#ffffff"><meta name=google-site-verification content="xetOSgBfIdaeBqM4aMPpxQJzsVP7a--l6tfp-hMo8T0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2 crossorigin=anonymous><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@600&family=Saira+Condensed:wght@500;600&family=PT+Sans&family=Saira+Extra+Condensed:wght@500;600;700&family=Inconsolata:wdth,wght@50..200,200..900&display=swap" rel=stylesheet><link rel=preload href=https://use.fontawesome.com/releases/v6.1.1/css/all.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://use.fontawesome.com/releases/v6.1.1/css/all.css></noscript><link rel=stylesheet type=text/css href=https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css><link rel=preload href=https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css integrity="sha512-QKC1UZ/ZHNgFzVKSAhV5v5j73eeL9EEN289eKAEFaAjgAiobVAnVv/AGuPbXsKl1dNoel3kNr6PYnSiTzVVBCw==" crossorigin=anonymous as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css integrity="sha512-QKC1UZ/ZHNgFzVKSAhV5v5j73eeL9EEN289eKAEFaAjgAiobVAnVv/AGuPbXsKl1dNoel3kNr6PYnSiTzVVBCw==" crossorigin=anonymous></noscript><link rel=stylesheet href=https://lucadrf.dev/css/resume.min.b9e583f15b5e7460e86017f44af9587fc0165f4f6d70aa3523704876dd272e55.css integrity="sha256-ueWD8VtedGDoYBf0SvlYf8AWX09tcKo1I3BIdt0nLlU=" media=screen><link rel=stylesheet href=https://lucadrf.dev/css/tweaks.min.b0e4e1bd32455e083ff01a9e60f558e192da461201fe79e4b7a79783f1d5d526.css integrity="sha256-sOThvTJFXgg/8BqeYPVY4ZLaRhIB/nnkt6eXg/HV1SY=" media=screen><link rel=stylesheet href=https://lucadrf.dev/css/resume-override.css></head><body id=page-top><nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id=sideNav><a class="navbar-brand js-scroll-trigger" href=#page-top><span class="d-block d-lg-none">Luca Da Rin Fioretto</span>
<span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src=/img/daro_profile.png alt>
</span></a><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class=navbar-nav><li class=nav-item><a class="nav-link js-scroll-trigger" href=/#about data-target=#about>About</a></li><li class=nav-item><a class="nav-link js-scroll-trigger" href=/#skills data-target=#skills>Skills</a></li><li class=nav-item><a class="nav-link js-scroll-trigger" href=/#experience data-target=#experience>Experience</a></li><li class=nav-item><a class="nav-link js-scroll-trigger" href=/#education data-target=#education>Education</a></li><li class=nav-item><a class="nav-link js-scroll-trigger" href=/#blog data-target=#blog>Blog</a></li></ul></div></nav><div class="container-fluid p-0"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=https://lucadrf.dev/>Home</a></li><li class=breadcrumb-item><a href=https://lucadrf.dev/blog/>Blogs</a></li><li class="breadcrumb-item active"><a href=https://lucadrf.dev/blog/taming-floating-points/>Taming Floating-Point Arithmetic in Python (Part 1)</a></li></ol></nav><div class="resp-container fit-breadcrumbs"><div class=fill><img src=https://i.ibb.co/SndJ6g0/rob-thompson-om-Uf5-OUJx-Xc-unsplash.jpg alt="'Mind the gap' sign on London's tube platform."></div></div><section class="resume-section p-3 p-lg-5 d-flex flex-column"><div class=my-auto><div class="mb-3 d-flex flex-row justify-content-between"><h2 class="portfolio mb-0"><span class=text-primary>Taming Floating-Point Arithmetic in Python (Part 1)</span></h2><span>May 26, 2024</span></div><div class=mb-5><h3 class=summary>First of a two parts series illustrating common gotchas in IEEE-754 floating-point arithmetic, with practical and realistic examples using Python&rsquo;s built-in float (double-precision)</h3></div><div><h2 id=introduction class=anchored-heading>Introduction <a class="header-link js-scroll-trigger" href=#introduction><i class="fa fa-link anchor-icons"></i></a></h2><p>If you&rsquo;re developing software that perform some sorts of numeric calculations,
there&rsquo;s a good chance that you&rsquo;ll have to deal with floating-point arithmetic.</p><p>In this blog post I&rsquo;ll show few practical cases where seemingly innocuous
floating-point operations can lead to considerable errors, and how such cases
can be treated in Python with the aid of <a href=https://docs.python.org/3/library/decimal.html>decimal</a>
and <a href=https://docs.python.org/3/library/fractions.html>fractions</a> modules.</p><h2 id=ieee-754-double-precision-floating-point-format class=anchored-heading>IEEE-754 Double-Precision Floating-Point format <a class="header-link js-scroll-trigger" href=#ieee-754-double-precision-floating-point-format><i class="fa fa-link anchor-icons"></i></a></h2><p>The default built-in type used for handling decimal numerals in Python is
<a href=https://docs.python.org/3/library/functions.html#float><code>float</code></a> which implements
<a href=https://en.wikipedia.org/wiki/Double-precision_floating-point_format>IEEE-754 Double-Precision Floating-Point format</a>, and its intrinsic pros and cons.</p><p>Doubles are represented as the result of a multiplication between a fraction
(significand) and an exponent and stored in a fixed length binary word of 64
bits (1 bit of sign, 11 bits of signed integer exponent and 52 bits of significand).</p><p><img alt="Floating-Point Double-precision format" src="https://i.ibb.co/DYvLDK5/Screenshot-2024-05-26-at-13-32-39.png?w=800" width=800></p><p><img alt="Floating-Point Double-precision value" src="https://i.ibb.co/yWgYs80/Screenshot-2024-05-26-at-13-33-42.png?w=400" width=400></p><p>Due to <em>double&rsquo;s</em> format fixed length, real numbers are (in most cases)
represented by approximations (i.e. the nearest representable number by a <em>double</em>)
For example 0.1, 0.2, 0.3 and 0.4 can&rsquo;t be represented exactly.
Also, due to the value of a <em>double</em> being the result of a multiplication, <em>double&rsquo;s</em>
values aren&rsquo;t evenly spread across the range or representable numbers.</p><p><img alt="Floating-Point Double-precision spread" src="https://i.ibb.co/890XSns/floatingpoints.png?w=800" width=800></p><p>From <a href=https://en.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64>Wikipedia</a>:</p><blockquote><p>Between 2<sup>52</sup> (4,503,599,627,370,496) and 2<sup>53</sup>
(9,007,199,254,740,992) the representable numbers are exactly <strong>the integers</strong>.</p><p>For the next range, from 2<sup>53</sup> to 2<sup>54</sup>, everything is
multiplied by 2, so the representable numbers are <strong>the even ones</strong>, etc.</p><p>Conversely, for the previous range from 2<sup>51</sup> to 2<sup>52</sup>,
the spacing is 0.5, etc.</p></blockquote><p>Hence, even though the larger absolute value representable with a <em>double</em> is
10<sup>308</sup>, it makes little sense to use <em>doubles</em> to represent
values greater than 2<sup>52</sup>.</p><p>Although the magnitude of the above numbers might seem &ldquo;extreme&rdquo; for &ldquo;regular&rdquo;
applications, floating-point approximation can create significant problems
when performing arithmetic operations with numbers at a much lower scale.</p><p><strong>Note</strong>: I haven&rsquo;t mentioned <em>subnormal</em> (or <em>denormal</em>) representation as it&rsquo;s
not relevant for the scope of this blog post.</p><h2 id=floating-points-notable-gotchas class=anchored-heading>Floating-Points notable gotchas <a class="header-link js-scroll-trigger" href=#floating-points-notable-gotchas><i class="fa fa-link anchor-icons"></i></a></h2><h3 id=addition-series-are-not-associative class=anchored-heading>Addition series are not associative <a class="header-link js-scroll-trigger" href=#addition-series-are-not-associative><i class="fa fa-link anchor-icons"></i></a></h3><p>Summing numbers with different orders of magnitude leads to larger approximation
errors than numbers of the same order of magnitude, hence changing the order in
which multiple sum operations are performed also changes the overall result.</p><p>Let&rsquo;s analise the following examples:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#0550ae>.9999</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.9999999999999996</span>
</span></span></code></pre></div><p>Note that <code>1.0</code> is (obviously) exactly representable with a <em>double</em>, however, the
above series of sums returns a <em>double</em> that is close but not exactly <code>1.0</code>.</p><p>This is because the Python interpreter executes operators with the same
precedence from left to right and the first sum operation that is encountered is
<code>.9999 + .00001</code> which is summing two numbers four order of magnitude apart. The
result of this operation is then summed by another <code>.00001</code>, again a sum between
two numbers four orders of magnitude apart, and again for the following sums.
So, we have a series of ten sums of different magnitudes and that generates
enough error that the overall resulting <em>double</em> is close but not quite <code>1.0</code>.</p><p>Summing the number with the same magnitude first returns a more accurate
result. In fact:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#0550ae>.9999</span> <span style=color:#0550ae>+</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span> <span style=color:#0550ae>+</span> <span style=color:#0550ae>.00001</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.0</span>
</span></span></code></pre></div><p>Note that this time we&rsquo;re summing numbers four order of magnitude apart only
once.</p><p>That solves the problem, in this case, but in practice you&rsquo;re much more likely
to encounter series of sums as a result of summing in a <code>for</code> loop or when using
built-in <code>sum()</code> (or similar third-party implementation) and summing arbitrary
iterables (with arbitrary numbers in them and that you don&rsquo;t know much about).</p><p>So you&rsquo;d have to implement an efficient algorithm to order the numbers by
magnitude before summing, which can be a bit of a pain and likely result in a
non-trivial performance hit.</p><h3 id=subtracting-nearly-equal-numbers-is-not-precise class=anchored-heading>Subtracting nearly equal numbers is not precise <a class="header-link js-scroll-trigger" href=#subtracting-nearly-equal-numbers-is-not-precise><i class="fa fa-link anchor-icons"></i></a></h3><p>Subtractions are also problematic, but unlike additions, problems arise when
subtracting numbers very close to each other. For example, imagine you&rsquo;re
calculating the distance between two pairs of points on a line:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#0550ae>17.9995</span> <span style=color:#0550ae>-</span> <span style=color:#0550ae>17.9975</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.0020000000000024443</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#0550ae>9.9995</span> <span style=color:#0550ae>-</span> <span style=color:#0550ae>9.9975</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.0019999999999988916</span>
</span></span></code></pre></div><p>The distance between <code>17.9995</code> and <code>17.9975</code> and between <code>9.9995</code> and <code>9.9975</code>
should be the same (<code>0.002</code>). However, the results of the two subtractions are
close but far enough that if we were to truncate at the third decimal place we&rsquo;d
have a result that&rsquo;s half of what it should have been. Or for instance, if we
wanted to trigger some kind of behaviour if the distance between two points was
<code>> 0.002</code> then the first pair of points would trigger it, but not the second
despite theoretically have the same exact distance.</p><p>In numerical analysis, this phenomenon is called
<a href=https://en.wikipedia.org/wiki/Catastrophic_cancellation><em>Catastrophic cancellation</em></a>.</p><p>At this point, I can almost hear some of you now laughing at the screen
thinking:</p><p><em>&ldquo;These aren&rsquo;t real issues. Nobody would be fool enough to compare
floats that way, compare the rounded numbers instead!&rdquo;</em></p><p>And you would be absolutely right, in this case. But often the code logic is
much more complex, and you might find yourself not having a fixed threshold but
rather a variable proportion, so you might have to round that number as well
and/or you might not know up to how many decimal places is &ldquo;safe&rdquo; to round.</p><h3 id=rounding class=anchored-heading>Rounding <a class="header-link js-scroll-trigger" href=#rounding><i class="fa fa-link anchor-icons"></i></a></h3><p>Rounding can be helpful when comparing or storing decimal numbers, it&rsquo;s <strong>always</strong>
preferable than truncating (unless you want to end up as the
<a href=https://en.wikipedia.org/wiki/Vancouver_Stock_Exchange>Vancouver Stock Exchange</a>)
but you should be aware that rounding is an operation that in most cases removes
information, hence precision.</p><p>If we consider the previous section&rsquo;s subtractions, Python&rsquo;s <code>round()</code> can help
in quantify the results to the significant digits we need. In fact:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>17.9995</span> <span style=color:#0550ae>-</span> <span style=color:#0550ae>17.9975</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.002</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>9.9995</span> <span style=color:#0550ae>-</span> <span style=color:#0550ae>9.9975</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.002</span>
</span></span></code></pre></div><p>So if rounding the result of the difference to three decimal places returns &ldquo;the
expected result&rdquo;, as in my reference system I&rsquo;m always and only interested in
three decimal places, surely the invariant would hold if the number were
previously rounded to the same number of decimal places. Well, most likely, not:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>9.9995</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span> <span style=color:#0550ae>-</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>9.9975</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>),</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.001</span>  <span style=color:#57606a># Hmmmmm....</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>17.9995</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span> <span style=color:#0550ae>-</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>17.9975</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>),</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.003</span>  <span style=color:#57606a># Wait, what?!</span>
</span></span></code></pre></div><p>Surely <code>round(9.9995, 3) == 10.0</code> and <code>round(9.9975, 3) == 9.998</code> which differ
by <code>0.002</code>. And surely <code>round(17.9995, 3) == 18.0</code> and <code>round(17.9975, 3) == 17.998</code> which also differs by <code>0.002</code>, right?!</p><p>Actually, no. In fact:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>9.9995</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>  <span style=color:#57606a># 9.9995 is represented by 9.9994999999999993889332472463138401508331298828125</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>9.999</span>  <span style=color:#57606a># Resulting in 9.999 as the fourth decimal place is 4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>9.9975</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>  <span style=color:#57606a># 9.9975 is represented by 9.9975000000000004973799150320701301097869873046875</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>9.998</span>  <span style=color:#57606a># Resulting in 9.998 as the fourth decimal place is 5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#0550ae>9.999</span> <span style=color:#0550ae>-</span> <span style=color:#0550ae>9.998</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.0010000000000012221</span>  <span style=color:#57606a># Which rounded is 0.001</span>
</span></span></code></pre></div><p>Similarly:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>17.9995</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>  <span style=color:#57606a># 17.9995 is represented by 17.999500000000001165290086646564304828643798828125</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>18.0</span>  <span style=color:#57606a># Resulting in 18.0 as the fourth decimal place is 5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>17.9975</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>)</span>  <span style=color:#57606a># 17.9975 is represented by 17.997499999999998721023075631819665431976318359375</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>17.997</span>  <span style=color:#57606a># Resulting in 17.997 as the fourth decimal place is 4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#0550ae>18.0</span> <span style=color:#0550ae>-</span> <span style=color:#0550ae>17.997</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.0030000000000001137</span>  <span style=color:#57606a># Which rounded is 0.003</span>
</span></span></code></pre></div><p>So in the first case the result is half what we expected in the second case is
one third more. Not great, considering that we&rsquo;re not dealing with numbers of
great magnitude in absolute terms. These are very common magnitudes.</p><p>On top of the above, is worth remembering that Python&rsquo;s built-in <code>round()</code>
implements IEEE-754 default rounding rule, that is &ldquo;Half to Even&rdquo;. Which means
that when (and only when) the fractional part of the decimal number is equal to
<code>0.5</code> then the integer part will be rounded to the nearest even. In fact:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>4.5</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>3.5</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>4.6</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> <span style=color:#6639ba>round</span><span style=color:#1f2328>(</span><span style=color:#0550ae>0.065</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>2</span><span style=color:#1f2328>)</span>  <span style=color:#57606a># 0.065 is represented by 0.065000000000000002220446049250313080847263336181640625</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>0.07</span>
</span></span></code></pre></div><p>And that&rsquo;s rounding for you.</p><p><a href=https://xkcd.com/2585/><img alt=xkcd.com/2585 src=https://imgs.xkcd.com/comics/rounding.png></a></p><h2 id=more-complex-examples class=anchored-heading>More complex examples <a class="header-link js-scroll-trigger" href=#more-complex-examples><i class="fa fa-link anchor-icons"></i></a></h2><p>All the above examples are interesting but real-life code is much more complex
than that. As mentioned, it&rsquo;s much more likely to have to deal with operations
executed in series as part of loops or functions, so let&rsquo;s have a look at some
more complex (and subtle) examples.</p><h3 id=the-significance-eater class=anchored-heading>The significance eater <a class="header-link js-scroll-trigger" href=#the-significance-eater><i class="fa fa-link anchor-icons"></i></a></h3><p>Consider the following function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#cf222e>def</span> <span style=color:#6639ba>significance_eater</span><span style=color:#1f2328>():</span>
</span></span><span style=display:flex><span>    x <span style=color:#0550ae>=</span> <span style=color:#0550ae>10.0</span> <span style=color:#0550ae>/</span> <span style=color:#0550ae>9.0</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>for</span> _ <span style=color:#0550ae>in</span> <span style=color:#6639ba>range</span><span style=color:#1f2328>(</span><span style=color:#0550ae>25</span><span style=color:#1f2328>):</span>
</span></span><span style=display:flex><span>        <span style=color:#6639ba>print</span><span style=color:#1f2328>(</span>x<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>        x <span style=color:#0550ae>=</span> <span style=color:#1f2328>(</span>x <span style=color:#0550ae>-</span> <span style=color:#0550ae>1.0</span><span style=color:#1f2328>)</span> <span style=color:#0550ae>*</span> <span style=color:#0550ae>10.0</span>
</span></span></code></pre></div><p>The idea is to show how, due to <code>float</code>&rsquo;s finite representation, significance
can be lost &ldquo;gradually&rdquo; by performing a series of operations on the same number.</p><p>Note that we&rsquo;re instantiating <code>x</code> to the value of 10/9 or
1.111&mldr;<sub>periodic</sub>, then at each iteration of the loop, we first
subtract 1 from the number, arithmetically resulting in 0.111&mldr;, then multiply
by 10, arithmetically resulting in 1.111&mldr; or the initial number.</p><p>So if <code>float</code> representation had unlimited memory, at the end of each iteration
of the above loop, the value of <code>x</code> would be unchanged. But <code>float</code> is
limited to 64bits so what happens when we run the above code is this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> significance_eater<span style=color:#1f2328>()</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111111111112</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111111111116</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.111111111111116</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111111111605</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111111116045</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111111160454</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111111604544</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111116045436</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111160454357</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111111604543567</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1111116045435665</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.111116045435665</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.11116045435665</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1116045435665</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.1160454356650007</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.160454356650007</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>1.6045435665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>6.045435665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>50.45435665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>494.5435665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>4935.435665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>49344.35665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>493433.5665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>4934325.665000696</span>
</span></span><span style=display:flex><span><span style=color:#0550ae>49343246.65000696</span>
</span></span></code></pre></div><p>At each iteration some significance is lost and after the 16<sup>th</sup>
iteration, <strong>all</strong> the initial information is lost.</p><p>This behaviour is similar to <em>Overflow</em> and <em>Underflow</em>, but it&rsquo;s harder to
spot and troubleshoot.</p><h3 id=simple-variance-calculator class=anchored-heading>Simple variance calculator <a class="header-link js-scroll-trigger" href=#simple-variance-calculator><i class="fa fa-link anchor-icons"></i></a></h3><p>Consider now the following a naïve implementation of a function for calculating
the variance of a series of numbers in a single pass:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#cf222e>import</span> <span style=color:#24292e>numpy</span> <span style=color:#cf222e>as</span> <span style=color:#24292e>np</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>def</span> <span style=color:#6639ba>simple_variance</span><span style=color:#1f2328>(</span>nums<span style=color:#1f2328>):</span>
</span></span><span style=display:flex><span>    sum_of_squares <span style=color:#0550ae>=</span> <span style=color:#0550ae>0</span>
</span></span><span style=display:flex><span>    sum_of_nums <span style=color:#0550ae>=</span> <span style=color:#0550ae>0</span>
</span></span><span style=display:flex><span>    N <span style=color:#0550ae>=</span> <span style=color:#6639ba>len</span><span style=color:#1f2328>(</span>nums<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>for</span> num <span style=color:#0550ae>in</span> nums<span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>        sum_of_squares <span style=color:#0550ae>+=</span> num<span style=color:#0550ae>**</span><span style=color:#0550ae>2</span>
</span></span><span style=display:flex><span>        sum_of_nums <span style=color:#0550ae>+=</span> num
</span></span><span style=display:flex><span>    variance <span style=color:#0550ae>=</span> <span style=color:#1f2328>(</span>sum_of_squares <span style=color:#0550ae>-</span> sum_of_nums<span style=color:#0550ae>**</span><span style=color:#0550ae>2</span> <span style=color:#0550ae>/</span> N<span style=color:#1f2328>)</span> <span style=color:#0550ae>/</span> N
</span></span><span style=display:flex><span>    <span style=color:#6639ba>print</span><span style=color:#1f2328>(</span><span style=color:#0a3069>f</span><span style=color:#0a3069>&#34;Real variance: </span><span style=color:#0a3069>{</span>np<span style=color:#0550ae>.</span>var<span style=color:#1f2328>(</span>nums<span style=color:#1f2328>)</span><span style=color:#0a3069>}</span><span style=color:#0a3069>&#34;</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>    <span style=color:#6639ba>print</span><span style=color:#1f2328>(</span><span style=color:#0a3069>f</span><span style=color:#0a3069>&#34;Simp variance: </span><span style=color:#0a3069>{</span>variance<span style=color:#0a3069>}</span><span style=color:#0a3069>&#34;</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>The explanation of the algorithm can be found <a href=https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance>here</a>.</p><p>Note that the above code prints the variance calculated using the naïve
approach just after the &ldquo;real&rdquo; variance calculated with a more sophisticated
algorithm defined in Numpy, so we can visually compare the two.</p><p>So if we call <code>simple_variance()</code> passing a list of integers, the algorithm
doesn&rsquo;t behave too badly:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> simple_variance<span style=color:#1f2328>([</span><span style=color:#0550ae>2</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>7</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>3</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>12</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>9</span><span style=color:#1f2328>])</span>
</span></span><span style=display:flex><span>Real variance<span style=color:#1f2328>:</span> <span style=color:#0550ae>13.84</span>
</span></span><span style=display:flex><span>Simp variance<span style=color:#1f2328>:</span> <span style=color:#0550ae>13.840000000000003</span>  <span style=color:#57606a># not bad</span>
</span></span></code></pre></div><p>But when we pass a very large list of large numbers with little variance, then
things gets weird:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> simple_variance<span style=color:#1f2328>(</span>np<span style=color:#0550ae>.</span>random<span style=color:#0550ae>.</span>uniform<span style=color:#1f2328>(</span><span style=color:#0550ae>1_000_000</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>1_000_000.06</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>100_000</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span>Real variance<span style=color:#1f2328>:</span> <span style=color:#0550ae>0.0003006493219911617</span>
</span></span><span style=display:flex><span>Simp variance<span style=color:#1f2328>:</span> <span style=color:#0550ae>0.02288</span>  <span style=color:#57606a># oh no...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0550ae>&gt;&gt;&gt;</span> simple_variance<span style=color:#1f2328>(</span>np<span style=color:#0550ae>.</span>random<span style=color:#0550ae>.</span>uniform<span style=color:#1f2328>(</span><span style=color:#0550ae>1_000_000</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>1_000_000.06</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>100_000</span><span style=color:#1f2328>))</span>
</span></span><span style=display:flex><span>Real variance<span style=color:#1f2328>:</span> <span style=color:#0550ae>0.00029977863201331316</span>
</span></span><span style=display:flex><span>Simp variance<span style=color:#1f2328>:</span> <span style=color:#0550ae>-</span><span style=color:#0550ae>0.00544</span>  <span style=color:#57606a># 乁(⊙_◎)ㄏ</span>
</span></span></code></pre></div><p>In the first call above, the error is two orders of magnitude while in the
call we get a negative variance (variance can&rsquo;t be negative)! This is very bad!</p><p>The problem here is again <em>catastrophic cancellation</em>, and in the above case
that happens when subtracting <code>sum_of_squares - sum_of_nums**2</code> as the sum of
squares is very close to the sum of nums squared.</p><p>The algorithm mentioned above is very well known for its cancellation problem,
but I think it&rsquo;s a good example to show how hard it can be to spot these kinds
of problems; imagine you had a similar algorithm working relatively fine with
certain sets of numbers and then returning &ldquo;garbage&rdquo; when the numbers change!</p><h2 id=conclusions class=anchored-heading>Conclusions <a class="header-link js-scroll-trigger" href=#conclusions><i class="fa fa-link anchor-icons"></i></a></h2><p>All the above is not only strictly related to Python, any language implementing
IEEE-754 Floating-Point arithmetic will have the exact same problems.</p><p>In the next chapter we&rsquo;re going to see how to tackle all the above problems
using only Python&rsquo;s standard library modules.</p><h2 id=references class=anchored-heading>References <a class="header-link js-scroll-trigger" href=#references><i class="fa fa-link anchor-icons"></i></a></h2><p>If you want to dive deeper into the theory behind the problem exposed in this
post, you should definitely start from these links:</p><ul><li><a href=https://docs.python.org/3/tutorial/floatingpoint.html>Floating Point Arithmetic: Issues and Limitations</a></li><li><a href=http://www.indowsway.com/floatingpoint.htm>The Perils of Floating Point</a></li><li><a href=https://www.cl.cam.ac.uk/teaching/1011/FPComp/fpcomp10slides.pdf>Floating Point Computation, Computer Laboratory, University of Cambridge</a></li><li><a href=https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#693>What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></li></ul><p>This blog post was inspired by the following practical guides:</p><ul><li><a href=https://docs.python.org/3/tutorial/floatingpoint.html>FP Issues and Limitations</a></li><li><a href=https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/>Examples of Floating Point problems</a></li><li><a href=https://www.soa.org/news-and-publications/newsletters/compact/2014/may/com-2014-iss51/losing-my-precision-tips-for-handling-tricky-floating-point-arithmetic/>Losing My Precision: Tips For Handling Tricky Floating Point Arithmetic</a></li></ul><p>Well done for getting here, see you soon in the next chapter!</p></div></div></section><span style=color:#999;font-size:60%>Copyright &copy; 2025 Luca Da Rin Fioretto.</span>
<span style=color:#999;font-size:60%>Based on <a href=https://github.com/eddiewebb/hugo-resume>hugo-resume</a> theme and generated with <a href=https://gohugo.io/>HUGO</a></span></div><script src=https://code.jquery.com/jquery-3.6.4.slim.min.js integrity="sha256-a2yjHM4jnF9f54xUQakjZGaqYs/V1CYvWpoqZzC2/Bw=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js integrity=sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx crossorigin=anonymous></script><script src=https://unpkg.com/smoothscroll-polyfill@0.4.4/dist/smoothscroll.min.js integrity=sha384-EYn4rWu1DHvYD0sSSSbMEtXQmMl58CFJd897806+RT1jJVYbhuZlZMN6yG9nCyFa crossorigin=anonymous></script><script src=https://unpkg.com/smoothscroll-anchor-polyfill@1.3.2/dist/index.min.js integrity=sha384-EY9NBEHCFbZANmPcTm7CgG8OhsFILy0VBLG85pF6OIpP42NVbZVNsFOc23PYTCkB crossorigin=anonymous></script><script async src=https://lucadrf.dev/js/resume.min.js></script></body></html>